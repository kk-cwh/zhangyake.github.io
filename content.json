{"meta":{"title":"THIS SPACE","subtitle":null,"description":null,"author":"jaak","url":"http://zhangyake.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2017-07-26T04:42:48.024Z","updated":"2017-07-26T04:42:48.024Z","comments":false,"path":"/404.html","permalink":"http://zhangyake.github.io//404.html","excerpt":"","text":".article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }"},{"title":"从前慢","date":"2015-10-13T12:58:11.000Z","updated":"2017-07-27T06:56:04.445Z","comments":true,"path":"about/index.html","permalink":"http://zhangyake.github.io/about/index.html","excerpt":"","text":"记得早先少年时大家诚诚恳恳说一句是一句清早上火车站长街黑暗无行人卖豆浆的小店冒着热气 从前的日色变得慢车马邮件都慢一生只够爱一个人从前的锁也好看钥匙精美有样子你锁了人家就懂了 从前的日色变得慢车马邮件都慢一生只够爱一个人从前的锁也好看钥匙精美有样子你锁了人家就懂了 var x, y, a; for (y = 1.5; y > -1.5; y -= 0.1) { var str = ''; for (x = -1.5; x < 1.5; x += 0.05) { a = x * x + y * y - 1; str += (a * a * a - x * x * y * y * y"},{"title":"近期书单","date":"2017-07-26T04:42:48.111Z","updated":"2017-07-26T04:42:48.111Z","comments":true,"path":"photo/index.html","permalink":"http://zhangyake.github.io/photo/index.html","excerpt":"","text":""},{"title":"","date":"2017-07-26T04:42:48.111Z","updated":"2017-07-26T04:42:48.111Z","comments":true,"path":"photo/output.json","permalink":"http://zhangyake.github.io/photo/output.json","excerpt":"","text":"[\"001zfzdr.jpg\",\"002fhxm.jpg\",\"003mtldswz.jpg\",\"004tyz.jpg\",\"005jyzhd.jpg\",\"007dssd.jpg\",\"006byx.jpg\"]"},{"title":"","date":"2017-07-26T04:42:48.112Z","updated":"2017-07-26T04:42:48.112Z","comments":true,"path":"photo/tool.js","permalink":"http://zhangyake.github.io/photo/tool.js","excerpt":"","text":"\"use strict\"; const fs = require(\"fs\"); const path = \"../../photos\"; fs.readdir(path, function (err, files) { if (err) { return; } let arr = []; (function iterator(index) { if (index == files.length) { fs.writeFile(\"output.json\", JSON.stringify(arr, null, \"\\t\")); return; } fs.stat(path + \"/\" + files[index], function (err, stats) { if (err) { return; } if (stats.isFile()) { arr.push(files[index]); } iterator(index + 1); }) }(0)); });"},{"title":"分类","date":"2017-07-26T04:42:48.111Z","updated":"2017-07-26T04:42:48.111Z","comments":true,"path":"categories/index.html","permalink":"http://zhangyake.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-07-26T04:42:48.113Z","updated":"2017-07-26T04:42:48.113Z","comments":true,"path":"tags/index.html","permalink":"http://zhangyake.github.io/tags/index.html","excerpt":"","text":""},{"title":"纯音乐","date":"2017-07-26T04:42:48.113Z","updated":"2017-07-26T04:42:48.113Z","comments":false,"path":"tags/music/index.html","permalink":"http://zhangyake.github.io/tags/music/index.html","excerpt":"","text":".article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }"},{"title":"","date":"2015-10-13T12:20:11.000Z","updated":"2017-07-27T06:34:34.109Z","comments":true,"path":"links/index.html","permalink":"http://zhangyake.github.io/links/index.html","excerpt":"","text":"记得早先少年时大家诚诚恳恳说一句是一句清早上火车站长街黑暗无行人卖豆浆的小店冒着热气 从前的日色变得慢车马邮件都慢一生只够爱一个人从前的锁也好看钥匙精美有样子你锁了人家就懂了 从前的日色变得慢车马邮件都慢一生只够爱一个人从前的锁也好看钥匙精美有样子你锁了人家就懂了 var x, y, a; for (y = 1.5; y > -1.5; y -= 0.1) { var str = ''; for (x = -1.5; x < 1.5; x += 0.05) { a = x * x + y * y - 1; str += (a * a * a - x * x * y * y * y"}],"posts":[{"title":"PHP调试环境搭建(xdebug+PHPstorm +Chrome插件 Xdbug helper)","slug":"phpdebug","date":"2017-01-08T03:35:50.000Z","updated":"2017-07-26T04:55:35.285Z","comments":true,"path":"2017/01/08/phpdebug/","link":"","permalink":"http://zhangyake.github.io/2017/01/08/phpdebug/","excerpt":"xdebug网站下载对应版本的扩展插件由于windows7(64位系统)上的php版本是7.0.6，此处下载的xdebug也是64位7.0的版本如图： 将下载的php_xdebug-2.5.0-7.0-vc14-x86_64.dll文件拷贝到php安装目录的ext文件夹中（我电脑是中D:\\phpEnv\\php7.0.6\\ext） 打开php.ini文件，在末尾添加下面代码片段: 123456zend_extension = \"D:\\phpEnv\\php7.0.6\\ext\\php_xdebug-2.5.0-7.0-vc14-x86_64.dll\"xdebug.remote_enable = Onxdebug.remote_handler = dbgpxdebug.remote_host = localhostxdebug.remote_port = 9000xdebug.idekey = PHPSTROM","text":"xdebug网站下载对应版本的扩展插件由于windows7(64位系统)上的php版本是7.0.6，此处下载的xdebug也是64位7.0的版本如图： 将下载的php_xdebug-2.5.0-7.0-vc14-x86_64.dll文件拷贝到php安装目录的ext文件夹中（我电脑是中D:\\phpEnv\\php7.0.6\\ext） 打开php.ini文件，在末尾添加下面代码片段: 123456zend_extension = \"D:\\phpEnv\\php7.0.6\\ext\\php_xdebug-2.5.0-7.0-vc14-x86_64.dll\"xdebug.remote_enable = Onxdebug.remote_handler = dbgpxdebug.remote_host = localhostxdebug.remote_port = 9000xdebug.idekey = PHPSTROM 打开PHPstorm 这里用的版本是phpstorm2016.2.2 ，进入File—&gt;Settings—&gt;Languages &amp; Frameworks—&gt;PHP—&gt;Servers 点击+号 添加 name： localhostHost: localhost Port: 80 Debugger: xdebug 之后点击Apply确认 进入PHP下的Debug 将xdebug的 debug port:设置为9000 和 xdebug.remote_port = 9000一致 其他默认 确定 ok即可 打开chrome浏览器 下载xdebug helper插件(可能要翻墙)，点击选项配置为phpstorm。如图 设置插件xdebug helper 状态打开如图 在phpstorme 打开下图中的按钮，设置断点，启动服务器即可进入调试查看：","categories":[{"name":"后端","slug":"后端","permalink":"http://zhangyake.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhangyake.github.io/tags/PHP/"}]},{"title":"PHP中的设计模式学习（C）","slug":"phpmodelc","date":"2017-01-04T08:11:28.000Z","updated":"2017-07-26T05:35:42.317Z","comments":true,"path":"2017/01/04/phpmodelc/","link":"","permalink":"http://zhangyake.github.io/2017/01/04/phpmodelc/","excerpt":"观察者模式观察者模式定义了对象间的一种一对多的依赖关系。以便一个对象的状态发生变化后，所有依赖它的对象都得到通知并自动刷新。该模式必须包含两个角色：观察者和被观察对象。观察者和被观察者之间存在观察的逻辑关联，当被观察者发生改变的时候，观察者就会观察到这样的变化，并且做出相应的响应。 在PHP SPL标准库中已经提供SplSubject(被观察对象)和SqlOberver(观察者) 接口. 12345678910111213/* 被观察对象 SplSubject 接口摘要 */SplSubject &#123;/* 方法 */abstract public void attach ( SplObserver $observer )abstract public void detach ( SplObserver $observer )abstract public void notify ( void )&#125;/* 观察者 SqlOberver 接口摘要 */SplObserver &#123;/* 方法 */abstract public void update ( SplSubject $subject )&#125; 具体实现代码示例：","text":"观察者模式观察者模式定义了对象间的一种一对多的依赖关系。以便一个对象的状态发生变化后，所有依赖它的对象都得到通知并自动刷新。该模式必须包含两个角色：观察者和被观察对象。观察者和被观察者之间存在观察的逻辑关联，当被观察者发生改变的时候，观察者就会观察到这样的变化，并且做出相应的响应。 在PHP SPL标准库中已经提供SplSubject(被观察对象)和SqlOberver(观察者) 接口. 12345678910111213/* 被观察对象 SplSubject 接口摘要 */SplSubject &#123;/* 方法 */abstract public void attach ( SplObserver $observer )abstract public void detach ( SplObserver $observer )abstract public void notify ( void )&#125;/* 观察者 SqlOberver 接口摘要 */SplObserver &#123;/* 方法 */abstract public void update ( SplSubject $subject )&#125; 具体实现代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 被观察者类的实现class Subject implements \\SplSubject&#123; private $observers = array(); /** * 添加观察者 * @param SplObserver $observer * @return mixed */ public function attach(SplObserver $observer) &#123; if (!in_array($observer, $this-&gt;observers)) &#123; $this-&gt;observers[] = $observer; &#125; &#125; /** * 移除观察者 * @param SplObserver $observer * @return mixed */ public function detach(SplObserver $observer) &#123; if (false != ($index = array_search($observer, $this-&gt;observers))) &#123; unset($this-&gt;observers[$index]); &#125; &#125; //完成自身功能后通知观察者 public function post() &#123; //post相关code //balabala …… $this-&gt;notify(); //完成自身功能后通知观察者 &#125; /** * 通知观察者 */ public function notify() &#123; foreach ($this-&gt;observers as $observer) &#123; $observer-&gt;update($this); &#125; &#125;&#125;//观察者1class Observer1 implements SplObserver&#123; /** * @param SplSubject $subject * @return mixed */ public function update(SplSubject $subject) &#123; echo \"执行观察者1 相关逻辑\"; // balabla &#125;&#125;//观察者2class Observer2 implements SplObserver&#123; /** * @param SplSubject $subject * @return mixed */ public function update(SplSubject $subject) &#123; echo \"执行观察者2 相关逻辑\"; // balabla &#125;&#125;$subject = new Subject(); //一个被观察者的实例$subject-&gt;attach(new Observer1());// 添加一个观察者$subject-&gt;attach(new Observer2());// 再添加又一个观察者$subject-&gt;post();// 被观察者执行自身任务，通知观察者事件触发执行 原型模式原型模式与工厂模式作用类似，也是用来创建对象的。不同的是，原型模式是先创建好一个原型对象，然后通过clone原型来创建新的对象，这样避免了类创建时的重复的初始化操作。原型模式主要适用于某些大型的结构复杂的对象的创建工作，创建一个对象需要大的开销，每次new消耗很大，使用原型模式只需内存拷贝即可。实现代码示例：12345678910111213141516171819202122232425262728293031323334353637// 声明一个克隆自身的接口 interface Prototype&#123; function copy();&#125;// 实现一个克隆自身的操作 class ConcretePrototype implements Prototype&#123; private $name; function __construct($name) &#123; $this-&gt;name = $name; &#125; public function getName() &#123; return $this-&gt;name; &#125; public function setName($name) &#123; $this-&gt;name = $name; &#125; //克隆 public function copy() &#123; return clone $this; &#125;&#125;$prototype = new ConcretePrototype('32');$pro1 = $prototype-&gt;copy(); //通过拷贝原型创建新的对象1$pro2 = $prototype-&gt;copy(); //通过拷贝原型创建新的对象2echo $pro1-&gt;getName();echo $pro2-&gt;getName(); 装饰器模式装饰器模式又叫装饰者模式。在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 组件对象接口interface ICompoment&#123; function Display();&#125;// 待装饰对象class Service implements ICompoment&#123; private $data ; function __construct($data) &#123; if (is_array($data))&#123; $this-&gt;data = $data; &#125; &#125; function Display() &#123; return $this-&gt;data; &#125;&#125;// 所有装饰器父类abstract class Decorator implements ICompoment&#123; protected $component; function __construct(ICompoment $component) &#123; $this-&gt;component = $component; &#125;&#125;// 具体装饰器1class RenderToJson extends Decorator &#123; function Display() &#123; $returnData = $this-&gt;component-&gt;Display(); return json_encode($returnData); &#125;&#125;// 具体装饰器2class RenderToXml extends Decorator &#123; function Display() &#123; $returnData = $this-&gt;component-&gt;Display(); $doc = new \\DOMDocument(); foreach ($returnData as $key =&gt; $value)&#123; $doc-&gt;appendChild($doc-&gt;createElement($key,$value)); &#125; return $doc-&gt;saveXML(); &#125;&#125;$service = new Service(array('name'=&gt;'Tom'));$service = new RenderToJson($service);var_dump($service-&gt;Display());$service1 = new Service(['name'=&gt;'Tom','age'=&gt;24,'sex'=&gt;'男']);$service1 = new RenderToXml($service1);var_dump($service1-&gt;Display()); 迭代器模式迭代器模式提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。为遍历不同的聚合结构提供一个统一的接口。PHP SPL标准库中已经提供 Iterator接口（迭代器接口）Iterator（迭代器）接口摘要 12345678Iterator extends Traversable &#123; /* 方法 */ abstract public mixed current ( void ) abstract public scalar key ( void ) abstract public void next ( void ) abstract public void rewind ( void ) abstract public boolean valid ( void )&#125; 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 实现Iterator的一个类class MyIterator implements \\Iterator &#123; private $position = 0; private $array = array( \"firstelement\", \"secondelement\", \"lastelement\", ); public function __construct() &#123; $this-&gt;position = 0; &#125; function rewind() &#123; // var_dump(__METHOD__); $this-&gt;position = 0; &#125; function current() &#123; // var_dump(__METHOD__); return $this-&gt;array[$this-&gt;position]; &#125; function key() &#123; // var_dump(__METHOD__); return $this-&gt;position; &#125; function next() &#123; // var_dump(__METHOD__); ++$this-&gt;position; &#125; function valid() &#123; // var_dump(__METHOD__); return isset($this-&gt;array[$this-&gt;position]); &#125;&#125;$it = new MyIterator;// 实现迭代器后就可以使用foreach循环迭代foreach($it as $key =&gt; $value) &#123; var_dump($key, $value); echo \"\\n\";&#125;//$it = new MyIterator;//while ($it-&gt;valid())&#123;// echo $it-&gt;current();// echo '&lt;br&gt;';// $it-&gt;next();//&#125; 代理模式代理模式为其他对象提供一种代理以控制这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。代理模式组成：抽象角色：通过接口或抽象类声明真实角色实现的业务方法。代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。代码示例： 12345678910111213141516171819202122232425262728293031323334353637// 抽象角色interface IRequest&#123; public function request($url);&#125;// 真实角色class RealObj implements IRequest&#123; function __construct() &#123; &#125; public function request($url) &#123; echo '请求链接:' . $url; //balabala &#125;&#125;// 代理角色class ProxyObj implements IRequest&#123; private $_client; private function client() &#123; if (!$this-&gt;_client instanceof RealObj) &#123; $this-&gt;_client = new RealObj(); &#125; return $this-&gt;_client; &#125; public function request($url) &#123; return $this-&gt;client()-&gt;request($url); &#125;&#125;$proxy = new ProxyObj();$proxy-&gt;request('http://www.google.com');","categories":[{"name":"后端","slug":"后端","permalink":"http://zhangyake.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhangyake.github.io/tags/PHP/"}]},{"title":"这首歌能听,不能下载？看这里","slug":"other01","date":"2016-12-30T08:44:07.000Z","updated":"2017-07-26T05:36:40.341Z","comments":true,"path":"2016/12/30/other01/","link":"","permalink":"http://zhangyake.github.io/2016/12/30/other01/","excerpt":"你是不是听到好听的歌曲总想点击下载，可时当你点击下载时却不能下载。这里提供一个解决方案，基本上网易云音乐啊，QQ音乐什么的 ，其他的酷狗，酷我音乐也类似 . 这里介绍一下网易云音乐和QQ音乐中一些歌曲点击下载时却不能下载小技巧。这里推荐使用Chrome浏览器吧，其他的也可以，不要告诉我你还在用IE 。—— 关爱前端程序员,请使用现代浏览器。","text":"你是不是听到好听的歌曲总想点击下载，可时当你点击下载时却不能下载。这里提供一个解决方案，基本上网易云音乐啊，QQ音乐什么的 ，其他的酷狗，酷我音乐也类似 . 这里介绍一下网易云音乐和QQ音乐中一些歌曲点击下载时却不能下载小技巧。这里推荐使用Chrome浏览器吧，其他的也可以，不要告诉我你还在用IE 。—— 关爱前端程序员,请使用现代浏览器。 比如这首歌 缘分一道桥（电影《长城》片尾曲） 在手机app网易云音乐上不能下载。 Next 来到浏览器 打开网易云音乐 http://music.163.com/找到这首你可以听却不能在手机上下载的这首歌的页面如下： 接下来，快捷键F12 打开 开发者控制台，点击下图中的Network，此时刷新页面(F5快捷键) 接下来点击上图中的Media 或者 Other 你想要的东西就在这里啦，点击播放按钮,你想要的就来了。看到mp3的后缀了么，双击打开页面右键另存为即可下载到电脑，修改名字即可 如果Media中没有 就在Other里了。看下图 具体的演示操作见下gif(网易云音乐) QQ音乐 操作演示见下gif 拿走,不谢","categories":[{"name":"分享","slug":"分享","permalink":"http://zhangyake.github.io/categories/分享/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://zhangyake.github.io/tags/其他/"}]},{"title":"PHP中的设计模式学习（B）","slug":"phpmodelb","date":"2016-12-29T08:14:18.000Z","updated":"2017-07-26T05:37:24.197Z","comments":true,"path":"2016/12/29/phpmodelb/","link":"","permalink":"http://zhangyake.github.io/2016/12/29/phpmodelb/","excerpt":"适配器模式适配器模式就是定义一个适配器接口，符合这些适配器的类必须继承并实现适配器方法。适配器模式简单的说就是将不同的函数接口封装成统一的API。实际应用的例子比如,PHP的数据库操作有mysql,mysqli,pdo 三种,(mysql操作 PHP7已经废弃了推荐用mysqli,pdo 代替),可以用适配器模式统一成一致(见下面代码示例). 类似的场景还有cache适配器,将memcache,redis,file,apc等不同的缓存函数,统一成一致，比如目前比较优雅的一个PHP框架 laravel 中的缓存的使用就是这样，不论是使用redis还是用memcache作为缓存，使用的方法都是一致的。","text":"适配器模式适配器模式就是定义一个适配器接口，符合这些适配器的类必须继承并实现适配器方法。适配器模式简单的说就是将不同的函数接口封装成统一的API。实际应用的例子比如,PHP的数据库操作有mysql,mysqli,pdo 三种,(mysql操作 PHP7已经废弃了推荐用mysqli,pdo 代替),可以用适配器模式统一成一致(见下面代码示例). 类似的场景还有cache适配器,将memcache,redis,file,apc等不同的缓存函数,统一成一致，比如目前比较优雅的一个PHP框架 laravel 中的缓存的使用就是这样，不论是使用redis还是用memcache作为缓存，使用的方法都是一致的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//定义一个适配器接口interface IDatabase&#123; function connect($host,$user,$pwd,$dbname); function query($sql); function close();&#125;// 实现适配器1class MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $pwd, $dbname) &#123; $conn = mysqli_connect($host,$user,$pwd,$dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return mysqli_query($this-&gt;conn,$sql); &#125; function close() &#123; mysqli_close($this-&gt;conn); &#125; &#125;// 实现适配器2class PDO implements IDatabase&#123; protected $conn; function connect($host, $user, $pwd, $dbname) &#123; $conn = new \\PDO(\"mysql:host=$host;dbname=$dbname\", $user, $pwd); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return $this-&gt;conn-&gt;query($sql); &#125; function close() &#123; unset($this-&gt;conn); &#125; &#125;$db = new MySQLi(); // or $db = new PDO(); // 这里无论你是使用 MySQLi 还是 PDO 下面调用都是一致的$db-&gt;connect('192.168.10.14','root','root','atest');$result = $db-&gt;query('SELECT * FROM tb_user');$db-&gt;close(); 策略模式策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互转换。策略模式让算法独立于使用它的客户而独立变化。策略模式的组成： 抽象策略角色： 策略类，通常由一个接口或者抽象类实现。 具体策略角色：包装了相关的算法和行为。 环境角色：持有一个策略类的引用，最终给客户端调用。PHP 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//抽象策略角色/** *定义策略基类 以及包含的策略方法 * 此处是一个出行旅游的方法 */interface TravelStrategy&#123; public function travelAlgorithm();&#125;//具体策略类 实现策略//1：乘坐飞机class AirPlaneStrategy implements TravelStrategy&#123; public function travelAlgorithm() &#123; echo 'travel by ariplane'; &#125;&#125;//具体策略类 实现策略//2：乘坐火车class TrainStrategy implements TravelStrategy&#123; public function travelAlgorithm() &#123; echo 'travel by train'; &#125;&#125;//具体策略类 实现策略//3：骑自行车class BicycleStrategy implements TravelStrategy&#123; public function travelAlgorithm() &#123; echo 'travel by bicycle'; &#125;&#125;/**环境类(Context): *用一个ConcreteStrategy对象来配置。 *维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。 *算法解决类，以提供客户选择使用何种解决方案： */class PersonContext&#123; private $_strategy = null; public function __construct(TravelStrategy $travel) &#123; $this-&gt;_strategy = $travel; &#125; public function setTravelStrategy(TravelStrategy $travel) &#123; $this-&gt;_strategy = $travel; &#125; public function travel() &#123; return $this-&gt;_strategy-&gt;travelAlgorithm(); &#125;&#125;//乘坐火车旅行$person = new PersonContext(new TrainStrategy()); // 设置，使用策略$person-&gt;travel();//改骑自行车$person-&gt;setTravelStrategy(new BicycleStrategy());// 设置策略，使用策略$person-&gt;travel(); 数据映射模式数据映射模式能更好的组织程序与数据库进行交互。它将对象和数据存储映射起来，对一个对象的操作会映射为数据库存储的操作。在代码中实现数据对象映射模式，实现一个ORM类，将复杂的sql语句映射成对象属性的操作。自己的代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 被操作的对象类class User&#123; public $id; public $name; function __construct()&#123;&#125; function __destruct()&#123;&#125; public function getId() &#123; return $this-&gt;id;&#125; public function setId($id) &#123; $this-&gt;id = $id; &#125; public function getName() &#123; return $this-&gt;name; &#125; public function setName($name) &#123; $this-&gt;name = $name; &#125;&#125; // 操作对象映射到数据库class UserMapper&#123; protected $db; function __construct() &#123; $this-&gt;db = new MySQLi(); // 见适配器模式的模式的MySQLi $this-&gt;db-&gt;connect('192.168.10.14', 'root', 'root', 'atest'); &#125; /** * @param User $user * @return bool * 保存user对象到数据库 */ function saveUser(User $user) &#123; if ($user-&gt;getId() === null) &#123; $sql = \"INSERT INTO tb_user (name) VALUES ( '\" . $user-&gt;getName() . \"')\"; $res = $this-&gt;db-&gt;query($sql); return $res; &#125; else &#123; $this-&gt;db-&gt;query(\"update tb_user set name = \" . $user-&gt;getName() . \" where id = \" . $user-&gt;getId()); return true; &#125; &#125; /** * @param $id * @return User|null * 从数据库中查询返回一个user对象 */ function findByUserId($id) &#123; $result = $this-&gt;db-&gt;query(\"select id , name from tb_user where id = \" . $id); if ($result) &#123; $result = $result-&gt;fetch_assoc(); $entry = new User(); $entry-&gt;setId($result['id']); $entry-&gt;setName($result['name']); return $entry; &#125; return null; &#125;&#125;//简单调用$userMapper = new UserMapper();$user = new User();// 创建对象$user-&gt;setName('jack chen');$res = $userMapper-&gt;saveUser($user);// 保存对象到数据库中var_dump($res);$user2 = $userMapper-&gt;findByUserId(1);// 查数据库 返回user对象var_dump($user2);","categories":[{"name":"后端","slug":"后端","permalink":"http://zhangyake.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhangyake.github.io/tags/PHP/"}]},{"title":"PHP中的设计模式学习（A）","slug":"phpmodel","date":"2016-12-28T01:44:48.000Z","updated":"2017-07-26T04:42:48.109Z","comments":true,"path":"2016/12/28/phpmodel/","link":"","permalink":"http://zhangyake.github.io/2016/12/28/phpmodel/","excerpt":"工厂模式简单来说工厂模式就是讲new操作封装在了工厂方法里，避免到处new某个对象。工厂模式是一种类，它具有为你创建对象的一些方法，你可以使用工厂类创建对象，而不直接使用new的方式创建对象。这样，当您想更改所创建的对象类型时，只需要更改工厂即可。使用该工厂的所有代码会自动更改。 123456789101112131415161718192021222324class User&#123; private $id; private $name; public function __construct($id, $name) &#123; $this-&gt;id = $id; $this-&gt;name = $name; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;// 工厂类class Factory&#123; public static function Create($id, $name) &#123; return new User($id, $name); &#125;&#125;","text":"工厂模式简单来说工厂模式就是讲new操作封装在了工厂方法里，避免到处new某个对象。工厂模式是一种类，它具有为你创建对象的一些方法，你可以使用工厂类创建对象，而不直接使用new的方式创建对象。这样，当您想更改所创建的对象类型时，只需要更改工厂即可。使用该工厂的所有代码会自动更改。 123456789101112131415161718192021222324class User&#123; private $id; private $name; public function __construct($id, $name) &#123; $this-&gt;id = $id; $this-&gt;name = $name; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;// 工厂类class Factory&#123; public static function Create($id, $name) &#123; return new User($id, $name); &#125;&#125; 单例模式单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。php单例代码： 12345678910111213141516171819202122232425class Singleton&#123; // 静态变量 跟类绑定，保存全局实例；私有化变量 避免通过类名::@instance 直接调用，防止为空 private static $instance; /* 私有化构造函数 ，防止外界实例化对象*/ private function __construct() &#123; &#125; // 私有化克隆函数，防止外界克隆对象 private function __clone() &#123; &#125; // 静态方法，单例访问的统一入口，返回唯一的对象实例 public static function getInstance() &#123; if (!(self::$instance instanceof self)) &#123; self::$instance = new self(); &#125; return self::$instance; &#125;&#125; 注册树模式注册树模式又叫注册模式/注册器模式，但是注册树模式更容易让人理解。注册树模式通过将对象实例注册到一棵全局的对象树上，需要的时候从对象树上采摘的模式设计方法。类似于小时候卖糖葫芦的将糖葫芦插在一个大的杆子上面，人们买的时候就取下来。不同的是，注册树模式摘下来还会有，能摘多次，糖葫芦摘一次就没有了 …… 注册树模式想解决什么问题单例模式解决的是如何在整个项目中创建唯一对象实例的问题，工厂模式解决的是如何不通过new建立实例对象的方法。首先，单例模式创建唯一对象的过程本身还有一种判断，即判断对象是否存在。存在则返回对象，不存在则创建对象并返回。 每次创建实例对象都要存在这么一层判断。 工厂模式更多考虑的是扩展维护的问题。 总的来说，单例模式和工厂模式可以产生更加合理的对象。怎么方便调用这些对象呢？而且在项目内如此建立的对象好像散兵游勇一样，不便统筹管理安排啊。因而，注册树模式应运而生。不管你是通过单例模式还是工厂模式还是二者结合生成的对象，都统统给我“插到”注册树上。我用某个对象的时候，直接从注册树上取一下就好。这和我们使用全局变量一样的方便实用。而且注册树模式还为其他模式提供了一种非常好的想法。三种模式的小结合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 创建单例class Singleton&#123; private static $instance; private function __construct() &#123;&#125; private function __clone() &#123;&#125; public static function getInstance() &#123; if (!(self::$instance instanceof self)) &#123; self::$instance = new self(); &#125; return self::$instance; &#125;&#125;// 工厂模式class Factory&#123; public static function factory()&#123; return Single::getInstance(); &#125;&#125;//注册树class Register&#123; protected static $objects; // 注册到全局树上 static function set($alias, $object) &#123; self::$objects[$alias] = $object; &#125; // 获取树上的对象 static function get($alias) &#123; return self::$objects[$alias] ; &#125; // 释放树上的对象 static function _unset($alias) &#123; unset(self::$objects[$alias]); &#125;&#125;// 注册Register::set('db',Factory::factory());// 其他地方使用注册的对象$DB = Register::get('db');","categories":[{"name":"后端","slug":"后端","permalink":"http://zhangyake.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhangyake.github.io/tags/PHP/"}]},{"title":"CSS笔记","slug":"css01","date":"2016-10-06T08:11:52.000Z","updated":"2017-07-26T04:42:48.025Z","comments":true,"path":"2016/10/06/css01/","link":"","permalink":"http://zhangyake.github.io/2016/10/06/css01/","excerpt":"CSS 样式基本知识 直接写在html标签中的样式 ，内联式css样式 eg： 1&lt;p style=\"color:red\"&gt;这里文字是红色。&lt;/p 写在当前文件中的样式，嵌入式css样式 eg： 12345&lt;style type=\"text/css\"&gt;span&#123;color:red;&#125;&lt;/style&gt;","text":"CSS 样式基本知识 直接写在html标签中的样式 ，内联式css样式 eg： 1&lt;p style=\"color:red\"&gt;这里文字是红色。&lt;/p 写在当前文件中的样式，嵌入式css样式 eg： 12345&lt;style type=\"text/css\"&gt;span&#123;color:red;&#125;&lt;/style&gt; 写在单独的文件中的样式，外部式css样式 eg： 1&lt;link href=\"main.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; 三种样式是有优先级的，他们的优先级：内联式 &gt; 嵌入式 &gt; 外部式（总结来说，就是–就近原则）但是嵌入式&gt;外部式有一个前提：嵌入式css样式的位置一定在外部式的后面 CSS 选择器 css样式定义中在{}之前的部分就是“选择器”，“选择器”指明了{}中的“样式”作用于网页中的哪些元素 标签选择器 就是选择html代码中的标签 &lt;html&gt;、&lt;body&gt;、&lt;h1&gt;、&lt;p&gt;、&lt;img&gt;等 1html标签&#123;css样式代码;&#125; 类选择器 为标签设置 class=&quot;类名称&quot; 英文圆点开头 1.class类名称&#123;css样式代码;&#125; ID选择器器 为标签设置id=&quot;ID名称&quot; 英文井号开头 1#ID名称&#123;css样式代码;&#125; 子选择器 大于符号(&gt;),用于选择指定标签元素的第一代子元素(儿子s女儿们) 1ul &gt; li &#123;border:1px solid red;&#125; ul下的子元素li（第一代子元素）加入红色实线边框。 包含(后代)选择器 加入空格,用于选择指定标签元素下的后辈元素 1ul &gt; li &#123;border:1px solid red;&#125; ul下的所有子元素li（所有子后代元素）加入红色实线边框。 子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。&gt; 作用于元素的第一代后代，空格作用于元素的所有后代 通用选择器 使用一个（*）号指定，它的作用是匹配html中所有标签元素 1* &#123;color:red;&#125; // html中任意标签元素字体颜色全部设置为红色 伪类选择符 允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色 a:hover{color:red;} 分组选择符 为html中多个标签元素设置同一个样式时，可以使用分组选择符（，） 1234h1,span&#123;color:red;&#125; 它相当于下面两行代码：h1&#123;color:red;&#125;span&#123;color:red;&#125; CSS的继承 层叠 和特殊性 继承 - CSS的某些样式是具有继承性的，继承就是子标签继承了上级标签的CSS样式的属性 特殊性 - 为同一个元素设置了不同的CSS样式代码，那么元素会启用哪一个CSS样式 ，浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式 ，权值的规则 ：标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100 层叠 - 就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用 重要性 有些特殊的情况需要为某些样式设置具有最高权值，可以使用!important来解决 eg：p{color:red!important;} CSS格式化排版 文字排版 123456789&#123; font-family:'宋体';// 字体 font-size:14px; // 字号 color:#fff; // 颜色 font-weight:bold; // 粗体 font-style:italic; // 斜体 text-decoration:underline;// 下划线 text-decoration:line-through; // 删除线&#125; 段落排版 1234567&#123; text-indent:2em; // 缩进 line-height:1.5em;// 行间距（行高） letter-spacing:50px;// 中文字间距、字母间距 word-spacing:50px;// 单词间距设置 text-align:center;// 对齐&#125; 元素分类 块级元素 在html中&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;就是块级元素。设置display:block就是将元素显示为块级元素， 每个块级元素都从新的一行开始，并且其后的元素也另起一行元素的高度、宽度、行高以及顶和底边距都可设置。元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 &lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码display:inline将元素设置为内联元素，内联元素和其他元素都在一行上；元素的高度、宽度及顶部和底部边距不可设置；元素的宽度就是它包含的文字或图片的宽度，不可改变 内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码 display:inline-block 就是将元素设置为内联块状元素，和其他元素都在一行上；元素的高度、宽度、行高以及顶和底边距都可设置 当为元素（不论之前是什么类型元素，display:none 除外）设置以下 2 个句之一：position : absolute; float : left 或 float:right 简单来说，只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，就可以设置元素的 width 和 height 盒子模型 css布局模型 流动模型（Flow） 流动（Flow）是默认的网页布局模型在流动模型下，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示 浮动模型 (Float) float:left; float:right;任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动 比如 float:left; 层模型（Layer） 层模型有三种形式： 绝对定位(position: absolute)设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 相对定位(position: relative)设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动 固定定位(position: fixed)设置position:fixed 表示固定定位，它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响","categories":[{"name":"前端","slug":"前端","permalink":"http://zhangyake.github.io/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://zhangyake.github.io/tags/CSS/"}]},{"title":"接口签名学习(一)","slug":"interfacesign01","date":"2016-05-13T07:36:48.000Z","updated":"2017-07-26T04:42:48.029Z","comments":true,"path":"2016/05/13/interfacesign01/","link":"","permalink":"http://zhangyake.github.io/2016/05/13/interfacesign01/","excerpt":"接口签名不同系统平台之间可能要互相调用彼此的一些服务,此时接口开发是各系统之间对接的重要方式，其数据是通过开放的互联网传输，对数据的安全性要有一定要求。为了提高传输过程参数的防篡改性，签名sign的方式是目前比较常用的方式，工作中使用的也是这种方式，应该属于数字签名的方式。也是目前国内互联网公司常用的一种方式。比如腾讯的支付接口签名. 参数sign生成的方法 第1步: 将所有参数（注意是所有参数），除去sign本身，以及值是空的参数，按参数名字母升序排序。 第2步: 然后把排序后的参数按参数1值1参数2值2…参数n值n的方式拼接成一个字符串。 第3步: 在上一步得到的字符串前面加上验证密钥key(这里的密钥key是接口提供方分配给接口接入方的)。 第4步: 计算第3步字符串的md5值(32位),然后转成大写,得到的字符串作为sign的值调用接口时把该sign值也发送过去。","text":"接口签名不同系统平台之间可能要互相调用彼此的一些服务,此时接口开发是各系统之间对接的重要方式，其数据是通过开放的互联网传输，对数据的安全性要有一定要求。为了提高传输过程参数的防篡改性，签名sign的方式是目前比较常用的方式，工作中使用的也是这种方式，应该属于数字签名的方式。也是目前国内互联网公司常用的一种方式。比如腾讯的支付接口签名. 参数sign生成的方法 第1步: 将所有参数（注意是所有参数），除去sign本身，以及值是空的参数，按参数名字母升序排序。 第2步: 然后把排序后的参数按参数1值1参数2值2…参数n值n的方式拼接成一个字符串。 第3步: 在上一步得到的字符串前面加上验证密钥key(这里的密钥key是接口提供方分配给接口接入方的)。 第4步: 计算第3步字符串的md5值(32位),然后转成大写,得到的字符串作为sign的值调用接口时把该sign值也发送过去。 这里自己写了一个node版本的生成sign的函数(代码写的不好,欢迎吐槽)，同时发布到了npm上https://www.npmjs.com/package/getsignature 123456789101112131415161718192021222324var crypto = require('crypto');var util = require('util');function getsignature(paramObject, secretKey) &#123; if( util.isObject(paramObject) &amp;&amp; !util.isArray(paramObject) &amp;&amp; secretKey!=null &amp;&amp; secretKey!='')&#123; var tmp = [];//存放参数名key var str = '';//存放拼接字符 for (var key in paramObject) &#123; tmp.push(key); &#125; //参数名排序 tmp.sort(); // 拼接字符串 key1+value1+key2+value2 for (var i = 0, len = tmp.length; i &lt; len; i++) &#123; str += (paramObject[tmp[i]] != null &amp;&amp; paramObject[tmp[i]] != '') ? (tmp[i] + '' + paramObject[tmp[i]]) : ''; &#125; //拼接秘钥 str = secretKey + str; // md5加密 str = crypto.createHash(\"md5\").update(str, 'utf8').digest(\"hex\"); return str.toUpperCase(); &#125; return '';&#125;module.exports = getsignature; 安装 1$ npm install getsignature 示例 123456789var getsignature = require('getsignature');// 生成签名所用参数 （调用外部接口要发送的参数）var params = &#123; 'name':'abc','age':24,'sex':1 &#125;;// 秘钥参数(约定好的)var secretKey = 'abcdef';// 获取签名参数var signature = getsignature(params, secretKey);console.log(signature); // '71A9D9D21A122E287DA3051A9573F313' 签名验证方法根据前面描述的签名参数sign生成的方法规则，计算得到参数的签名值，和参数中通知过来的sign对应的参数值进行对比，如果是一致的，那么就校验通过，如果不一致，说明参数被修改过。示例:（假定上方的node系统调用的是一个php接口） 123456789101112131415161718192021222324&lt;?php $secretKey = 'abcdef';//先前约定好的秘钥 //接受到的参数不包含sign参数 放进一个数组中 $param = array('name' =&gt;'abc','age'=&gt;24,'sex'=&gt;1 ); $sign = $_REQUEST['sign']; //同样的方式计算签名 function getSignature($param, $secretKey) &#123; if(!is_array($param))&#123; return NULL; &#125; ksort($param); $str = ''; foreach ($param as $key=&gt;$value) &#123; if($value!=NULL &amp;&amp; $value!='')&#123; $str .= ($key.$value); &#125; &#125; $str= $secretKey. $str; return strtoupper(md5($str)); &#125; //比较签名是否一致 echo (getSignature($param, $secretKey) == $sign )?'签名有效':'参数被修改过'; 参考文档:http://kf.qq.com/faq/120322fu63YV130422aqUNJv.html参考文档:http://www.tuicool.com/articles/jQJV3i参考文档:http://www.oicto.com/web-api-sign-key-a/","categories":[{"name":"后端","slug":"后端","permalink":"http://zhangyake.github.io/categories/后端/"}],"tags":[{"name":"node","slug":"node","permalink":"http://zhangyake.github.io/tags/node/"}]},{"title":"webpack入门","slug":"webpack01","date":"2016-03-30T03:12:42.000Z","updated":"2017-07-26T04:42:48.111Z","comments":true,"path":"2016/03/30/webpack01/","link":"","permalink":"http://zhangyake.github.io/2016/03/30/webpack01/","excerpt":"什么是 webpack？webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。它就是一个前端工具，可以让我们进行各种模块加载，预处理后，再打包。任何静态资源都可以视作模块，然后模块之间也可以相互依赖，通过webpack对模块进行处理后，可以打包成我们想要的静态资源。","text":"什么是 webpack？webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。它就是一个前端工具，可以让我们进行各种模块加载，预处理后，再打包。任何静态资源都可以视作模块，然后模块之间也可以相互依赖，通过webpack对模块进行处理后，可以打包成我们想要的静态资源。 安装webpack 首先需要安装node.js环境,见node官网.安装nodejs后使用npm 安装 webpack命令 1$ npm install webpack -g 这样webpack 命令即能在全局环境下使用 webpack小示例第一步 创建空目录Demo文件夹 文件夹中创建app空文件夹在app文件夹中创建entry.js文件文件内容如下 –entry.js 1document.write(\"It works.\"); 在app文件夹中创建 index.html 文件内容如下 –index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;webpack入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"bundle.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 执行命令： 12$ cd Demo/app$ webpack ./entry.js bundle.js 该命令会对entry.js文件编译并创建一个bundle.js文件如果成功的话，它会显示如下： 123456Hash: ca188ee5789bb780fcecVersion: webpack 1.13.0Time: 65ms Asset Size Chunks Chunk Namesbundle.js 1.42 kB 0 [emitted] main [0] ./entry.js 28 bytes &#123;0&#125; [built] 在浏览器中打开index.html 显示 It works. 第二步依赖文件加载 在app文件夹下添加content.js内容为 1module.exports = \"It works from content.js.\"; 更改entry.js文件内容为: 1document.write(require(\"./content.js\")); 执行命令： 1$ webpack ./entry.js bundle.js 刷新浏览器index.html页面, 显示It works from content.js.webpack会分析你的输入文件的依赖的其他文件。这些文件（称为模块）都会最终包含在你的bundle.js中。webpack会给每个模块的一个独特的ID以及保存所有模块的ID以便在bundle.js文件访问。仅在启动时执行输入模块，在运行时提供需要的功能，并在需要时执行依赖. 第一次使用loaders 我们要添加一个CSS文件到我们的示例中 webpack只能处理JavaScript本身，所以我们需要css-loader去装载CSS文件,同样也需要style-loader。执行命令 1$ npm install css-loader style-loader 在app文件夹下添加style.css文件 文件内容如下–style.css 123body &#123; background: yellow;&#125; 更新entry.js文件 12require(\"!style!css!./style.css\");document.write(require(\"./content.js\")); 执行命令： 1$ webpack ./entry.js bundle.js 刷新浏览器index.html页面, 显示带有黄色背景的It works from content.js. webpack只能处理JavaScript本身，style.css通过!style!css!装载机管道以特定的方式中改变输出 bundle.js 文件的内容。这些转换后的结果是一个JavaScript模块。如果我们不想使用 require(“!style!css!./style.css”);而想直接使用require(“./style.css”);更新entry.js文件内容为: 12require(\"./style.css\");document.write(require(\"./content.js\")); 执行命令时要绑定加载模块： 1$ webpack ./entry.js bundle.js --module-bind 'css=style!css' 刷新浏览器index.html页面, 显示同样的效果。 某些环境下这里可能要用双引号 “css=style!css” 使用配置文件 webpack.config.js 在Demo文件夹下创建webpack.config.js文件内容如下: 123456789101112module.exports = &#123; entry: \"./app/entry.js\", output: &#123; path: __dirname, filename: \"./app/bundle.js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: \"style!css\" &#125; ] &#125;&#125;; 现在只需要在Demo目录下执行命令: 12345678910 $ webpack执行成功会显示: Hash: ab14e3789227f2cbf6c0 Version: webpack 1.13.0 Time: 955ms Asset Size Chunks Chunk Names ./app/bundle.js 11.8 kB 0 [emitted] main [0] ./app/entry.js 67 bytes &#123;0&#125; [built] [5] ./app/content.js 45 bytes &#123;0&#125; [built] + 4 hidden modules webpack会自动加载当前目录下的webpack.config.js文件 漂亮的输出随着项目的增长，编译可能需要更长的时间。所以我们要展示一些进度条、颜色…可以使用命令 1$webpack --progress --colors 使用watch model使用watch model模式时，可理解为监听模式,如果检测到任何文件更改，它将再次运行编译。 1$webpack --watch 使用webpack开发服务器 12// npm 全局安装webpack开发服务器$ npm install webpack-dev-server -g 1234567在Demo文件夹下执行 $ webpack-dev-server --progress --colorswebpack-dev-server 会在本地提供一个静态文件服务器 http://localhost:8080/webpack-dev-server/同时内部也在使用webpack的watc模式自动编译更新浏览器中打开http://localhost:8080/webpack-dev-server/只要文件有更新 浏览器也会自动刷新页面。 参考文档:http://webpack.github.io/docs/tutorials/getting-started","categories":[{"name":"工具","slug":"工具","permalink":"http://zhangyake.github.io/categories/工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://zhangyake.github.io/tags/webpack/"}]},{"title":"js 深浅拷贝 &&  js 函数参数传递","slug":"ecmascript04","date":"2016-02-20T02:02:45.000Z","updated":"2017-07-26T04:42:48.029Z","comments":true,"path":"2016/02/20/ecmascript04/","link":"","permalink":"http://zhangyake.github.io/2016/02/20/ecmascript04/","excerpt":"浅拷贝我所理解的 javascript中的数组或者对象的浅拷贝 是增加了一个指向同一个内存地址的变量;由于指向的内存地址相同,改变任一变量的值,会引起另一变量跟随变化。","text":"浅拷贝我所理解的 javascript中的数组或者对象的浅拷贝 是增加了一个指向同一个内存地址的变量;由于指向的内存地址相同,改变任一变量的值,会引起另一变量跟随变化。 12345678910111213141516var arr1 = [1,2,3];var arr2 = arr1; // 浅拷贝 （arr2与arr1指向同一个内存地址）var obj1 = &#123;a:1&#125;;var obj2 = obj1;// 浅拷贝（obj2与obj1指向同一个内存地址）// 由于指向的内存地址相同 改变任一变量的值 会引起另一变量跟随变化console.log(arr1);console.log(arr2);console.log(obj1);console.log(obj2);// 改变arr2 obj2 的属性 arr2[1] = 100;obj2.a=2;console.log(arr1);console.log(arr2);console.log(obj1);console.log(obj2); 深拷贝深拷贝一般都是开辟一块新的内存地址，将原数组或者对象的各个属性逐个复制出去,新对象拥有原对象的各个属性，是两个独立的对象 ，不会互相影响。 12345678var obj1 = &#123;a:1,b:2&#125;;var obj2 = JSON.parse(JSON.stringify(obj1)); //深拷贝console.log(obj1);console.log(obj2);//给obj2添加属性cobj2.c = 3;console.log(obj1);console.log(obj2); JSON.parse(JSON.stringify( obj )) 进行深拷贝时 正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构，但是坏处也显而易见，这会抛弃对象的constructor，也就是深复制之后，无论这个对象原本的构造函数是什么，在深复制之后都会变成Object javascript中的函数参数传递 函数的参数一般包括基本类型 和 引用类型对于基本类型 数字、字符串等是将它们的值传递给了函数参数，函数参数的改变不会影响函数外部的变量。对于引用类型 数组和对象等是将对象(数组)的变量的值（内存地址）传递给了函数参。当函数改变这个地址指向的对象(数组)的 内容 时，同时也改变了函数外部变量指向的对象(数组)的内容；当函数改变的是变量的地址时，实际就与函数外部的变量失去了联系，变成了完全不同的对象了，不会对函数外部对象造成改变。 123456789101112var a1=1;var a2=[];var a3=&#123;&#125;;function fun(a1,a2,a3)&#123; a1=3; a2=[1,2,3]; a3=&#123;a:3&#125;;&#125;fun(a1,a2,a3)a1 // 1a2 // []a3 // Object &#123;&#125; a1、a2、a3 都没有被改变，a1 仍然是原来的数字，a2、a3 仍然是空白的数组、对象。js中的函数参数都是按值传递的 只是 数组、对象等按值传递，是指变量地址的值。 1234567891011121314var a1=1;var a2=[];var a3=&#123;&#125;;function fun(a1,a2,a3)&#123; a1 = 3; a2.push(2); a3.a = 3;&#125;undefinedfun(a1,a2,a3)undefineda1 // 1a2 // [2]a3 // Object &#123;a: 3&#125; 外部a2、a3的值发生了改变即如果不赋新值（不改变对象地址），而是在函数内部 直接对数组或者对象的内容进行操作 则会改变外部对象或数组的内容","categories":[{"name":"前端","slug":"前端","permalink":"http://zhangyake.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhangyake.github.io/tags/JavaScript/"}]},{"title":"JS中的 call与apply方法 以及 bind方法","slug":"ecmascript03","date":"2016-01-30T06:28:25.000Z","updated":"2017-07-26T04:42:48.029Z","comments":true,"path":"2016/01/30/ecmascript03/","link":"","permalink":"http://zhangyake.github.io/2016/01/30/ecmascript03/","excerpt":"call 与apply 类似 都是与函数相关的方法，每个函数都包含这两个特殊的方法 apply( ) 和 call( ) 这两个方法都是在特定的作用域中调用函数，即将函数作为对象的方法来调用。调用格式:function.apply(obj,args);","text":"call 与apply 类似 都是与函数相关的方法，每个函数都包含这两个特殊的方法 apply( ) 和 call( ) 这两个方法都是在特定的作用域中调用函数，即将函数作为对象的方法来调用。调用格式:function.apply(obj,args); apply方法有两个 参数 其中 obj 代表调用function的对象，在函数体中，obj是设置函数体内this对象的值。args代表的参数是一个数组,数组中的值时传递给function的参数值。function.call(obj,args. . .); call方法的参数obj与apply中的类似，args. . . 则表示要绑定扫函数上的0-n个参数值,call与apply的区别就在于传递给函数的参数必须逐个列举出来如果obj参数为null，则使用全局对象。使用call or apply方改变函数的作用域的好处 就是对象不需要与方法有任何的耦合关系, 参数obj为不同的对象 返回值可能就随对象obj的而定 1234567891011121314151617181920var a=10,b=11;function add(x,y)&#123; if(x &amp;&amp; y)&#123; return x+y; &#125; return this.a + this.b;&#125;var obj=&#123;a:1,b:2&#125;add();//21add(2,3);//5add.call(obj);//3add.call(obj,2,4);//6add.apply(obj);//3add.apply(obj,[3,4,5]);//7 bind( )也是函数的一个方法,这个方法会返回一个作为方法调用的函数，其this值会被绑定到传给bind( )函数的值; 123456789var name = 'Jaak';var word = 'Hello';function say()&#123; alert(this.name+\" say \"+this.word); &#125; say(); var p = &#123;name:'Tom',word:'Hi'&#125;; var sayp = say.bind(p); sayp(); //chrome浏览器中运行 查看结果","categories":[{"name":"前端","slug":"前端","permalink":"http://zhangyake.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhangyake.github.io/tags/JavaScript/"}]},{"title":"JS中特殊的对象arguments","slug":"ecmascript02","date":"2016-01-24T08:58:11.000Z","updated":"2017-07-26T04:42:48.029Z","comments":true,"path":"2016/01/24/ecmascript02/","link":"","permalink":"http://zhangyake.github.io/2016/01/24/ecmascript02/","excerpt":"arguments对象在函数代码中，才可使用特殊对象 arguments，arguments对象不能显式创建。函数的 arguments 对象并不是一个数组，但是访问单个参数的方式与访问数组元素的方式相同。访问函数中的第n个参数 则可以使用arguments[n-1]","text":"arguments对象在函数代码中，才可使用特殊对象 arguments，arguments对象不能显式创建。函数的 arguments 对象并不是一个数组，但是访问单个参数的方式与访问数组元素的方式相同。访问函数中的第n个参数 则可以使用arguments[n-1]通过索引访问函数参数一个简单的add函数中实践一下arguments对象(以下代码都是在chrome浏览器中非严格模式运行)由上图可看出 在add函数中通过arguments访问参数的方式与访问数组元素的方式相同 arguments是函数中的一个对象对add函数进行简单修改如下图由上图运行结果 则说明arguments的确是一个对象arguments对象的一些属性再次修改add函数 查看关于arguments对象的其他属性如下图从运行结果中看到 arguments对象喊包含length 和 callee这样的属性 arguments.length 是函数接受参数的个数（实参个数） arguments.callee 则代表当前正在执行的函数 它可以在匿名函数中通过callee递归调用自身 图中的蓝色框线中看到 callee还包含有其他属性输出arguments.callee.length长度是2 和 arguments.length 输出的3 不同 arguments.length 是实参长度 arguments.callee.length 是形参长度 arguments.callee还有一个属性caller arguments.callee.caller 保存着调用当前函数的函数的引用 由于当前函数是在全局作用域中运行 所以看到 caller是null 看下图 arguments.callee.caller则是调用当前函数的函数的引用修改代码 如下在outFun函数中调用add函数则arguments.callee.caller则指向了outFun函数 关于caller 函数对象也存在一个caller属性 通函数名称调用 含义与 arguments.callee.caller 都是保存着调用当前函数的函数的引用 上图 funName函数中输出funName.caller 在outFun函数中调用funName函数 执行outFun函数 输出的是 图中红色框线部分输出的是outFun 即调用funName函数的函数引用 注意关于使用arguments通过索引获取函数参数 在非严格模式与严格模式下 稍有不同图中在非严格模式下更改 函数参数 x 的值时arguments[0]的值随其改变 同样更改arguments[0] 的值 x的值也随其改变图中在严格模式下更改 函数参数 x 的值时arguments[0]的值并不会改变 同样更改arguments[0] 的值 x的值也不会随其改变如图","categories":[{"name":"前端","slug":"前端","permalink":"http://zhangyake.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhangyake.github.io/tags/JavaScript/"}]},{"title":"JavaScript类型转换","slug":"ecmascript01","date":"2015-12-19T12:59:54.000Z","updated":"2017-07-26T04:42:48.026Z","comments":true,"path":"2015/12/19/ecmascript01/","link":"","permalink":"http://zhangyake.github.io/2015/12/19/ecmascript01/","excerpt":"一、类型介绍 JavaScript中，共有6种类型，其中5种是基本类型，1种复杂类型。 基本类型：number、boolean、string、null、undefined 复杂类型：Object 5种基本类型中，处理null、undefined外都有相应的包装类。 除了5种基本类型之外，所有的类型都是Object类型的。 typeof操作符是JavaScript中用以判断类型的操作符，返回6种全小写的字符串，分别是’number’、’boolean’、’string’ 、’null’、’undefined’。 其次 还有数组Array类型 实质上也是Object类型","text":"一、类型介绍 JavaScript中，共有6种类型，其中5种是基本类型，1种复杂类型。 基本类型：number、boolean、string、null、undefined 复杂类型：Object 5种基本类型中，处理null、undefined外都有相应的包装类。 除了5种基本类型之外，所有的类型都是Object类型的。 typeof操作符是JavaScript中用以判断类型的操作符，返回6种全小写的字符串，分别是’number’、’boolean’、’string’ 、’null’、’undefined’。 其次 还有数组Array类型 实质上也是Object类型 其中null类型和Object类型的都返回’object’，function也是Object类型的，但是由于其在JavaScript中的特殊性，所以有必要单独区分！ typeof操作的执行结果： 二、其他类型转boolean Boolean() 引起的转型 规则是： 非0数字（含Infinity） –&gt; true Object对象 –&gt; true 非空字符串 –&gt; true 0/NaN –&gt; false null –&gt; false undefined –&gt; false ‘’ –&gt; false !! 引起的转型 与使用Boolean()一致 ! 引起的转型 if()引起的转型 &amp;&amp; 和 || 引起的转型包含两种情况： a、两边确实是boolean，经过逻辑运算，返回相应的值。 true &amp;&amp; false --&gt; false， true || false --&gt; true b、两边不是boolean 下列写法，大家肯定会常常见到。 var t = a &amp;&amp; b ； //相当于 var t = a ? b : a; return a &amp;&amp; b； //相当于 return a ? b : a; a &amp;&amp; test()； //相当于 a ? test() : null; var t = a || b ; //相当于 var t = a ? a : b; 三、其它类型转number转number共有3个函数：Number()、parseInt()、parseFloat() 1、Number()引起的转型 规则是： true --&gt; 1 false --&gt; 0 如果字符串中只包含数字 如&apos;123&apos; --&gt; 123 如果字符串中包含有效的浮点数字 如&apos;123.99&apos; --&gt;123.99 如果字符串是有效的十六进制数字 如&apos;0xFF&apos; --&gt; 255 如果字符串是空串 &apos;&apos; --&gt; 0 如果字符串包含上述格式之外字符 如&apos;123a&apos; --&gt; NaN 如果是对象 则调用对象的valueOf方法，然后按照上述规则进行转换， 如果没有valueOf方法，则调用对象的toString方法，然后按照上述规则进行转换。 如果valueOf和toString都存在，则调用valueOf方法！！！ 注意：Number会忽略前导0 2、parseInt/parseFloat引起的转型 规则是： null, undefined, &apos;&apos;, true, false --&gt; NaN 如果字符串中只包含数字 如 &apos;123&apos; --&gt; 123 如果字符串中包含有效的浮点数字 如&apos;123.99&apos; parseInt --&gt; 123, parseFloat --&gt; 123.99 如果字符串是有效的十六进制数字 如 parseInt &apos;0xFF&apos; --&gt; 255 parseFloat &apos;0xFF&apos; --&gt; 0 解析字符串，直到某个字符不是数字为止 parseInt &apos;123a&apos; --&gt; 123 parseFloat &apos;123.3a&apos; --&gt; &apos;123.3&apos; 如果参数是Object类型，会调用toString()方法。注意：并不会调用valueOf方法！！！ 3、+, - ,*, /,%, ++, -- 都会引起类型转换，转换规则同1。 四、其它类型转string 1、String()引起的转型 规则是： 如果值有toString()方法，则调用该方法(无参数)，并返回相应的结果 如果值是null，则返回&apos;null&apos; 如果值是undefined， 返回&apos;undefined&apos; 2、+ &apos;&apos; 引起的转型，规则同1。如 var str = null + &apos;&apos; // &apos;null&apos; var str = undefined + &apos;&apos; // &apos;undefined&apos; var str = {toString:function(){return &apos;i am a object&apos;}} + &apos;&apos; // &apos;i am a object&apos; 五、包装类型var num = new Number(123) 转型规则同Number() var bool = new Boolean(true) 转型规则同Boolean() var str = new String(&apos;123a&apos;) 转型规则同String() 包装类型转换大招： var val = Object(arg) 如果arg是Object类型，原样返回 如果arg是number，boolean，string，则返回相应的包装实例 如果arg是null，undefined，则返回 {} 注意：var val = new Object(arg) 跟不带new的结果一致！！！ 六、toString() 和 valueOf() 调用问题 +,-,*,/,%,++,--,Number,isNaN,isFinite 会导致这两个方法被调用，valueOf存在就调用valueOf，不存在就调用toString，两者都存在，调用valueOf parseInt/parseFloat/String() 会导致toString方法被调用。。并不会调用valueOf！！！ 七、&gt;、&gt;=、&lt;、&lt;=引起的转换规则是： 如果两个操作数都是数值，则执行数值比较 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值 如果一个操作数是数值，则将另外一个操作数转换成一个数值，然后执行比较 如 2 &gt; &apos;1&apos; ，会把&apos;1&apos; 转成 1，然后和2比较 如果一个操作数是对象，则调用这个对象的valueOf方法，用得到的结果，按照前3条的规则转换之后执行比较，如果对象没有valueOf方法，则调用toString方法，用得到的结果，按照前3条的规则转换之后执行 比较。 如果一个操作数是boolean值，则先将七转换为数值，然后执行比较。true --&gt; 1、false --&gt; 0。 八、== 引起的转型 规则是： 如果有一个操作数是NaN，马上返回false。 如果有一个操作数是boolean值，则在比较相等性之前，先转成数值，false转0，true转1。 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转为数值。 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf方法，用得到的基本类型值按照前面的规则进行比较。 null == undefined --&gt; true 如果两个操作数是对象，则比较它们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回true，否则，返回false 参考原文：http://www.imooc.com/article/2382","categories":[{"name":"前端","slug":"前端","permalink":"http://zhangyake.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhangyake.github.io/tags/JavaScript/"}]},{"title":"redis命令学习(三)","slug":"redis03","date":"2015-11-28T08:25:12.000Z","updated":"2017-07-26T04:42:48.110Z","comments":true,"path":"2015/11/28/redis03/","link":"","permalink":"http://zhangyake.github.io/2015/11/28/redis03/","excerpt":"有序集合(ZSet)操作命令 Redis 有序集合与普通集合非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个评分，这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但评分可以重复。","text":"有序集合(ZSet)操作命令 Redis 有序集合与普通集合非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个评分，这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但评分可以重复。 使用有序集合你可以以非常快的速度添加、删除和更新元素。因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！ 简而言之使用有序集合你可以做完成许多对性能有极端要求的任务，而那些任务使用其他类型的数据库真的是很难完成的。 ZADD 命令 - 添加成员在redis中，使用ZADD命令将一个或多个 member 元素及其 score 值加入到有序集 key 当中基本语法：1ZADD key score member [[score member] [score member] ...] 示例 - 添加google.com,baidu.com,sougou.com到website集合，评分5 , 4 , 3。12127.0.0.1:6379&gt; ZADD website 5 google.com 4 baidu.com 3 sougou.com (integer) 3 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。score 值可以是整数值或双精度浮点数。如果 key 不存在，则创建一个空的有序集并执行ZADD操作。当 key 存在但不是有序集类型时，返回一个错误。 ZRANGE命令 - 获取指定区域成员如果想要获取集合成员，可以使用ZRANGE命令基本语法：1ZRANGE key start stop [WITHSCORES] 示例 - 获取website集合的全部成员。1234567127.0.0.1:6379&gt; ZRANGE website 0 -1 WITHSCORES # 显示整个有序集成员 1) \"sougou.com\" 2) \"3\" 3) \"baidu.com\" 4) \"4\" 5) \"google.com\"6) \"5\" 返回的成员的位置按 score 值递增(从小到大)来排序。 ZSCORE命令 - 获取成员评分redis中使用ZSCORE命令来获取成员评分基本语法：1ZSCORE key member 示例 - 获取集合website中元素google.com的评分。12127.0.0.1:6379&gt; ZSCORE website google.com # 注意返回值是字符串\"5\" 如果 google.com 是集合 website 的成员，则返回成员 google.com 的评分值。如果 google.com 元素不是有序集 website 的成员，或 website 不存在，则返回 nil 。 ZREM命令 - 移除成员ZREM命令可以移除指定成员基本语法：1ZREM key member [member ...] 示例 - 移除website集合中google.com元素。1234567127.0.0.1:6379&gt; ZREM website google.com (integer) 1127.0.0.1:6379&gt; ZRANGE website 0 -1 WITHSCORES #显示没有google.com 1) \"sougou.com\" 2) \"3\" 3) \"baidu.com\" 4) \"4\" 执行成功，google.com元素将从website集合中移除，如果google.com不存在，将被忽略。如果 website 集合存在但不是有序集类型时，返回一个错误。 ZCARD命令 - 获取成员数量如果需要查看集合成员的数量，那么我们需要使用到ZCARD命令基本语法：1ZCARD key 示例 - 查看website集合的成员数量。12127.0.0.1:6379&gt; ZCARD website(integer) 2 执行成功，将返回有序集 website 的成员总数。 ZCOUNT命令 - 获取评分区域成员数量除了ZCARD命令以外，ZCOUNT命令也可以查看成员的数量，和前者不同的是，ZCOUNT命令可以设定评分的最小和最大值基本语法：1ZCOUNT key min max 示例 - 查看评分在4-5之间的website。1234567127.0.0.1:6379&gt; ZCOUNT salary 4 5 (integer) 1127.0.0.1:6379&gt; ZRANGE website 0 -1 WITHSCORES # baidu.com 4 1) \"sougou.com\" 2) \"3\" 3) \"baidu.com\" 4) \"4\" 执行成功，将返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。 ZRANK命令 - 排名ZRANK命令可以获取到给定元素在集合中的排名，排名依据 评分（score） 值递增(从小到大)顺序排列基本语法：1ZRANK key member 示例 - 显示 baidu.com 的评分排名。 1234567127.0.0.1:6379&gt; ZRANGE website 0 -1 WITHSCORES 1) \"sougou.com\" 2) \"3\" 3) \"baidu.com\" 4) \"4\"127.0.0.1:6379&gt; ZRANK website baidu.com (integer) 1 排名以 0 为底，也就是说， score 值最小的成员排名为 0 。使用 ZREVRANK 命令可以获得成员按 score 值递减(从大到小)排列的排名。1234567127.0.0.1:6379&gt; ZREVRANK website baidu.com (integer) 0 127.0.0.1:6379&gt; ZRANGE website 0 -1 WITHSCORES 1) \"sougou.com\" 2) \"3\" 3) \"baidu.com\" 4) \"4\" ZINCRBY 命令 - 增量ZINCRBY命令可以为给定的成员评分值加上增量语法格式：ZINCRBY key increment member示例 - 为website集合中的baidu.com加分5。123456789101112127.0.0.1:6379&gt; ZRANGE website 0 -1 WITHSCORES 1) \"sougou.com\" 2) \"3\" 3) \"baidu.com\" 4) \"4\" # 原来 4127.0.0.1:6379&gt; ZINCRBY website 5 baidu.com # 加分5 \"9\"127.0.0.1:6379&gt; ZRANGE website 0 -1 WITHSCORES 1) \"sougou.com\" 2) \"3\" 3) \"baidu.com\" 4) \"9\" # 加后 9 可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。当 key 不是有序集类型时，返回一个错误。score 值可以是整数值或双精度浮点数。 Key相关命令KEYS命令 - 查找键Redis 的keys命令用于管理键。使用 Redis 的keys命令,查找所有符合给定模式 pattern 的 key 。语法格式：1KEYS pattern 示例 - 查找包含a的键。12345127.0.0.1:6379&gt; MSET name \"zhang\" age 24 sex 1 #设置三个键值对 OK 127.0.0.1:6379&gt; KEYS *a* 1) \"age\" 2) \"name\" KEYS 匹配数据库中所有 key 。KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。KEYS hllo 匹配 hllo 和 heeeeello 等。KEYS h[ae]llo 匹配 hello 和 hallo 。特殊符号用 \\ 隔开。 EXISTS命令 - 判断key是否存在EXISTS命令的作用是判断指定key是否存在语法格式：1EXISTS key 示例 - 判断age是否存在。1234127.0.0.1:6379&gt; MSET name \"zhang\" age 24 sex 1 OK 127.0.0.1:6379&gt; EXISTS age (integer) 1 若 key 存在，返回 1 ，否则返回 0 MOVE命令 - 移动keyMOVE命令的作用是将当前数据库的 key 移动到给定的数据库 db 当中语法如下：1MOVE key db 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。示例 - 将数据库0中的age，移动到数据库1。123456789101112127.0.0.1:6379&gt; SELECT 0 # redis默认使用数据库0，为了清晰起见，这里再显式指定一次 OK 127.0.0.1:6379&gt; MOVE age 1 (integer) 1 127.0.0.1:6379&gt; EXISTS age (integer) 0 127.0.0.1:6379&gt; SELECT 1 OK 127.0.0.1:6379[1]&gt; EXISTS age #注意命令提示符变成127.0.0.1:6379[1] 表明正在使用数据库 1 (integer) 1 RENAME命令 - 重命名RENAME命令可以将原有的 key 修改为新的key名称语法如下：1RENAME key newkey 示例 - 重命名name 为 lastname。12345678127.0.0.1:6379&gt; GET name # 获取当前name的值 \"zhang\" 127.0.0.1:6379&gt; RENAME name lastname # 重命名name 为 lastname OK 127.0.0.1:6379&gt; GET name # 获取当前name的值 已经不存在 (nil)127.0.0.1:6379&gt; GET lastname \"zhang\" 当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。当 newkey 已经存在时， RENAME 命令将覆盖旧值。 SORT命令 - 排序排序是很常见的需求，在 redis 中可以使用SORT命令来实现排序语法格式：1SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE destination] 示例 对一个number列表排序123456789101112131415161718127.0.0.1:6379&gt; LPUSH number 6 2 5 9 1 3 8 (integer) 7 127.0.0.1:6379&gt; SORT number 1) \"1\" 2) \"2\" 3) \"3\" 4) \"5\" 5) \"6\" 6) \"8\" 7) \"9\"127.0.0.1:6379&gt; SORT number DESC 1) \"9\" 2) \"8\" 3) \"6\" 4) \"5\"5) \"3\"6) \"2\"7) \"1\" 使用SORT命令，可以返回或保存给定列表、集合、有序集合 key 中经过排序的元素。排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。 DUMP命令 - 序列化redis 支持序列化，使用DUMP命令来序列化给定key的值语法如下：1DUMP key 示例 - 序列化name。123456127.0.0.1:6379&gt; SET name \"jaak\"OK127.0.0.1:6379&gt; GET name\"jaak\"127.0.0.1:6379&gt; DUMP name\"\\x00\\x04jaak\\x06\\x00\\x02\\xd6\\xed3n\\x91d\\xe5\" 执行DUMP命令序列化成功后，将返回被序列化的值，若key不存在，则返回 nil 。 EXPIRE命令 - 设置生存时间为key设置生存时间需要使用EXPIRE命令语法格式：1EXPIRE key seconds 示例 - 设置name的过期时间为20秒。1234567127.0.0.1:6379&gt; GET name\"jaak\" 127.0.0.1:6379&gt; EXPIRE name 20(integer) 1 # 20秒后执行127.0.0.1:6379&gt; GET name(nil) 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。 生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。 TTL命令 - 获取剩余生存时间TTL命令的作用是获取给定 key 剩余生存时间(TTL, time to live)语法格式：1TTL key 示例 - 查看key剩余生存时间。1234127.0.0.1:6379&gt; EXPIRE sex 1000(integer) 1127.0.0.1:6379&gt; TTL key(integer) 996 当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangyake.github.io/categories/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zhangyake.github.io/tags/redis/"}]},{"title":"redis命令学习(二)","slug":"redis02","date":"2015-11-27T07:45:51.000Z","updated":"2017-07-26T04:42:48.110Z","comments":true,"path":"2015/11/27/redis02/","link":"","permalink":"http://zhangyake.github.io/2015/11/27/redis02/","excerpt":"列表(Lists)操作命令 Redis列表是简单的字符串列表，按照插入顺序排序。","text":"列表(Lists)操作命令 Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）LPUSH命令插入一个新的元素导头部,而RPUSH插入一个新元素导尾部.当一个这两个操作在一个空的Key上被执行的时候一个新的列表被创建。相似的，如果一个列表操作清空一个列表那么对应的key将被从key空间删除。这是非常方便的语义，因为他们被调用使用一个空列表完全就像他们被调用时使用一个不存在的键值（可以）做为参数 LPUSH命令 - 添加元素LPUSH的作用是将一个或多个值 value 插入到列表 key 的表头基本语法：1LPUSH key value [value ...] 示例：将java添加到语言列表。12127.0.0.1:6379&gt; LPUSH languages \"java\"(integer) 1 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头,比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a 。如果 key 不存在，一个空列表会被创建并执行LPUSH操作。执行成功时，返回列表长度，当 key 存在但不是列表类型时，返回一个错误。 LSET命令 - 设置指定位置元素LSET可以将列表 key 下标为index的元素的值设置为 value基本语法：1LSET key index value 示例12127.0.0.1:6379&gt; LSET languages 0 \"nodejs\"OK 需要注意的是，列表 key 必须是已存在的，而且index不能超出列表长度范围。 LINDEX命令 - 获取指定位置元素如果要获取列表元素，LINDEX命令是比较常用的，使用LINDEX，我们可以获取到指定位置的 value基本语法：1LINDEX key index 示例 - 获取languages的第一个元素。12127.0.0.1:6379&gt; LINDEX languages 0\"nodejs\" 下标 (index)为正数时，0表示第一个元素，1表示第二个元素，以此类推。下标 可以是负数，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 LPOP命令 - 取出元素LPOP命令执行时会移除列表第一个元素，并将其返回基本语法：1LPOP key 示例 - 取出languages中的第一个元素。12127.0.0.1:6379&gt; LPOP languages\"nodejs\" 请注意，LPOP命令会移除列表中的元素，如果仅仅是想要获取该元素，那么就不应该使用LPOP操作，因为redis中有专门获取元素的命令。 LINSERT命令 - 插入元素插入元素是一个必要功能，LINSERT可以将值 value 插入到列表 key 当中，位于值 pivot 之前或之后基本语法：LINSERT key BEFORE|AFTER pivot value示例 - 将node插入到JS之前。1234127.0.0.1:6379&gt; LPUSH languages \"java\" \"JS\"(integer) 2127.0.0.1:6379&gt; LINSERT languages BEFORE \"JS\" \"node\"(integer) 3 当 pivot 不存在于列表 key 时，不执行任何操作。当 key 不存在时， key 被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。 LREM命令 - 移除元素在redis中，移除列表元素使用LREM命令，根据参数 count 的值，移除列表中与参数 value 相等的元素基本语法：1LREM key count value 示例 - 移除languages中，所有的名叫‘JS’的元素。12127.0.0.1:6379&gt; LREM languages 0 \"JS\"(integer) 1 count 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。count = 0 : 移除表中所有与 value 相等的值。 LEN命令 - 列表长度在redis中，LLEN命令可以获取到列表的长度，基本语法：1LLEN key 示例 - 查看languages列表长度。12127.0.0.1:6379&gt; LLEN languages(integer) 2 返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 。如果 key 不是列表类型，返回一个错误。 LTRIM命令 - 剪切列表LTRIM可以对一个列表进行修剪，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除基本语法：1LTRIM key start stop 示例 - 只保留列表 languages 的前2个元素，其余元素全部删除。12127.0.0.1:6379&gt; LTRIM languages 0 1OK 下标(index)参数start和stop都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 集合(Set)操作命令Redis 集合（Set）是一个无序的字符串集合. 。Redis 集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素，最终在集合里只会有一个元素。 实际上说这些就是意味着在添加元素的时候无须检测元素是否存在。 一个Redis集合的非常有趣的事情是他支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（unions）, 求交集（intersections）,求差集（differences of sets）。 SADD命令 - 添加集合操作中，SADD命令可以将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略基本语法：1SADD key member [member ...] 示例 - 添加‘Tom’到room集合中。12127.0.0.1:6379&gt; SADD room \"Tom\"(integer) 1 假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误。 SPOP命令 - 随机取出如果我们需要随机取出集合中的某个元素，可以使用SPOP命令基本语法：1SPOP key 示例:随机取出room集合中的元素。12127.0.0.1:6379&gt; SPOP room\"Tom\" 需要注意的是，执行SPOP命令返回的元素将被移除该集合。 SMEMBERS命令 - 获取全部元素如果要获取集合中全部的元素，则需要使用SMEMBERS命令基本语法：1SMEMBERS key 示例 - 获取room集合中全部的元素。12127.0.0.1:6379&gt; SMEMBERS room(empty list or set) SMEMBERS命令只会返回集合中的全部成员，并不会移除它们，如果集合不存在，则视为空集合。 SCARD命令 - 元素数量如果想要查看集合中元素的数量，可以使用SCARD命令基本语法：1SCARD key 示例 - 查看room集合中元素的数量。12127.0.0.1:6379&gt; SCARD room(integer) 0 执行SCARD命令，当集合存在时，返回集合中元素的数量，若集合不存在，则返回0。 SDIFF命令 - 差集假如现在有两个集合，我们想要获取到它们之间不同的元素，通常情况下，我们需要通过循环集合来比较，然后取得不同的元素。在redis里面取得集合的差集非常简单，通过SDIFF命令即可轻松实现基本语法：1SDIFF key [key ...] 示例 - 取得room1和room2的差集。12345678910127.0.0.1:6379&gt; SADD room1 \"Tom\" \"Jack\" (integer) 2127.0.0.1:6379&gt; SADD room2 \"jaakzhang\" \"Tom\"(integer) 2127.0.0.1:6379&gt; SDIFF room1 room2 #这里room1在前 返回的结果以room1为主体 从room1中去掉room2中相同的元素1) \"Jack\"127.0.0.1:6379&gt; SDIFF room2 room1 #这里room2在前 返回的结果以room2为主体 从room2中去掉room1中相同的元素1) \"jaakzhang\" 如果 key 都存在，则返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集。 SINTER命令 - 交集在 redis 中获取集合的交集也是非常简单的，执行SINTER命令将返回集合的交集基本语法：1SINTER key [key ...] 示例 - 获取集合room1和room2的交集。12345678910127.0.0.1:6379&gt; SMEMBERS room11) \"Jack\"2) \"Tom\"127.0.0.1:6379&gt; SMEMBERS room21) \"jaakzhang\"2) \"Tom\"127.0.0.1:6379&gt; SINTER room1 room21) \"Tom\"127.0.0.1:6379&gt; SINTER room2 room11) \"Tom\" 当集合都存在时，将返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的集合被视为空集。因此，当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。 SUNION命令 - 并集既然有差集和交集运算，当然少不了并集，在 redis 中，执行SUNION命令将返回给定集合的并集基本语法：1SUNION key [key ...] 示例：获取集合room1和room2的并集。12345678910127.0.0.1:6379&gt; SMEMBERS room11) \"Jack\"2) \"Tom\"127.0.0.1:6379&gt; SMEMBERS room21) \"jaakzhang\"2) \"Tom\"127.0.0.1:6379&gt; SUNION room1 room21) \"jaakzhang\"2) \"Jack\"3) \"Tom\" 如果给定的集合都存在，则返回一个集合的全部成员，该集合是所有给定集合的并集。同样，不存在的集合被视为空集。 SISMEMBER命令 - 包含判断如果要判断集合是否包含某个元素也不需要循环对比了，因为 redis 提供SISMEMBER命令可以实现这个功能基本语法：1SISMEMBER key member 示例 - 判断 Tom 元素是否集合 room1 的成员。12345127.0.0.1:6379&gt; SMEMBERS room11) \"Jack\"2) \"Tom\"127.0.0.1:6379&gt; SISMEMBER room1 \"Tom\"(integer) 1 如果集合包含给定的元素，则返回1，反之则返回0。 SMOVE命令 - 移动元素执行SMOVE可以移动元素基本语法：1SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合。SMOVE是原子性操作，因此可以保证数据的一致性。 示例 - 将room1集合中的‘Jack’移动到‘room2’集合。1234567891011121314127.0.0.1:6379&gt; SMEMBERS room11) \"Jack\"2) \"Tom\"127.0.0.1:6379&gt; SMEMBERS room21) \"jaakzhang\"2) \"Tom\"127.0.0.1:6379&gt; SMOVE room1 room2 \"Jack\"(integer) 1127.0.0.1:6379&gt; SMEMBERS room21) \"Jack\"2) \"jaakzhang\"3) \"Tom\"127.0.0.1:6379&gt; SMEMBERS room11) \"Tom\" 如果 source 集合不存在或不包含指定的 member 元素，则SMOVE命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。当 destination 集合已经包含 member 元素时，SMOVE命令只是简单地将 source 集合中的 member 元素删除。当 source 或 destination 不是集合类型时，返回一个错误。 SREM命令 - 移除元素执行命令SREM可以将元素从集合中移除基本语法：1SREM key member [member ...] 示例 - 从room1集合中移除”Tom” 123456127.0.0.1:6379&gt; SMEMBERS room11) \"Tom\"127.0.0.1:6379&gt; SREM room1 \"Tom\"(integer) 1127.0.0.1:6379&gt; SMEMBERS room1(empty list or set) 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangyake.github.io/categories/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zhangyake.github.io/tags/redis/"}]},{"title":"redis 命令学习(一)","slug":"redis01","date":"2015-11-24T12:11:07.000Z","updated":"2017-07-26T04:42:48.110Z","comments":true,"path":"2015/11/24/redis01/","link":"","permalink":"http://zhangyake.github.io/2015/11/24/redis01/","excerpt":"String操作命令String 是 redis 中最基础的数据类型， redis 字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512兆为上限。","text":"String操作命令String 是 redis 中最基础的数据类型， redis 字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512兆为上限。 SET命令 - 添加键值SET命令是将字符串值 value 关联到 key 。 语法格式：1SET key value [EX seconds] [PX milliseconds] [NX|XX] 如果 key 已经持有其他值，SET就覆写旧值，无视类型。因此，对于某个原本带有生存时间（TTL）的键来说， 当SET命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。示例：添加键key1，值为”test”12127.0.0.1:6379&gt; SET key1 \"test\"OK SETEX命令 - 添加值和生存时间 SETEX命令的作用是将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在， SETEX命令将覆写旧值语法格式：1SETEX key seconds value 示例 - 设置name的值为‘jaak’，生存时间为60秒。12127.0.0.1:6379&gt; SETEX name 60 \"jaak\"OK SETEX命令的作用类似如下两个命令：12SET name \"jaak\"EXPIRE name 60 # 设置生存时间 不同之处是，SETEX是一个原子性(atomic)操作， 关联值 和 设置生存时间 两个动作会在同一时间内完成，该命令在 Redis 用作缓存时，非常实用。 GET命令 - 获取字符串 GET命令是返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil 。假如 key 储存的值不是字符串类型，返回一个错误，因为GET只能用于处理字符串值语法格式：1GET key 示例 - 获取name和key的值。12345127.0.0.1:6379&gt; GET name\"jaak\"127.0.0.1:6379&gt; GET key(nil)返回值 当key不存在时，返回nil，否则返回key的值。如果key的值不是字符串类型，那么将会返回一个错误。 APPEND命令 - 追加字符串如果 key 已经存在并且是一个字符串，APPEND命令将 value 追加到 key 原来的值的末尾，语法格式：1APPEND key value 示例 - 向name追加字符‘ zhang’。 1234127.0.0.1:6379&gt; APPEND name \" zhang\" # 对已存在的字符串进行 APPEND(integer) 10127.0.0.1:6379&gt; GET name“jaak zhang\" 如果 key 不存在，APPEND就简单地将给定 key 设为 value ，就像执行 SET key value 一样。 MSET命令 - 添加多个键值 MSET命令可以同时设置一个或多个 key-value 对，如果某个给定 key 已经存在，那么MSET会用新值覆盖原来的旧值语法格式：1MSET key value [key value ...] 示例 - 设置name、age和number的值。 127.0.0.1:6379&gt; MSET name “jaak” age “24” number “158234232”OKMSET是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。 MGET命令 - 获取多个键值执行MGET命令，将返回所有(一个或多个)给定 key 的值语法格式：1MGET key [key ...] 示例 - 获取name、age、number 、sex的值。12345127.0.0.1:6379&gt; MGET name age number sex1) \"jaak\"2) \"24\"3) \"158234232\"4) (nil) 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。 SETRANGE命令 - 覆写SETRANGE命令是用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量offset开始。不存在的 key 当作空白字符串处理,语法格式：1SETRANGE key offset value 示例 - 覆写name的值。 123456127.0.0.1:6379&gt; SET name \"jaak\"OK127.0.0.1:6379&gt; SETRANGE name 4 \"zhang\"(integer) 11127.0.0.1:6379&gt; GET name\"jaakzhang\" SETRANGE命令会确保字符串足够长以便将 value 设置在指定的偏移量上，如果给定 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )，那么原字符和偏移量之间的空白将用零字节(zerobytes, “\\x00” )来填充。注意你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。 STRLEN命令 - 获取键值长度STRLEN命令将会返回 key 所储存的字符串值的长度语法格式：1STRLEN key 示例 - 获取name值的长度。12127.0.0.1:6379&gt; STRLEN name(integer) 9 值得注意的是当 key 储存的不是字符串值时，返回一个错误。 其他命令除了前面提到的那些常用命令以外，还有很多其他的命令，真正用到的时候再来详细了解如何使用它。 命令 用途GETSET 设置键的字符串值，并返回旧值。GETRANGE 得到字符串的子字符串存放在一个键。GETBIT 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。SETBIT 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。SETNX 将 key 的值设为 value ，当且仅当 key 不存在。MSETNX 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。PSETEX 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。INCR 将 key 中储存的数字值增一。INCRBY 将 key 所储存的值加上指定增量。INCRBYFLOAT 为 key 中所储存的值加上指定浮点数增量。DECR 将 key 中储存的数字值减一。DECRBY 将 key 所储存的值加上指定增量。 哈希（Hash）操作命令Redis Hashes是字符串字段和字符串值之间的映射,因此他们是展现对象的完美数据类型。 HSET命令 - 添加键值 在 redis 中，使用HSET命令来将哈希表 key 中的域 field 的值设为 value语法如下：1HSET key field value 示例 - 添加键name ，值为‘jaak zhang’。12127.0.0.1:6379&gt; HSET man name \"jaak zhang\" # 设置一个新域(integer) 1 如果 key 不存在，一个新的哈希表被创建并进行HSET操作。如果域 field 已经存在于哈希表中，旧值将被覆盖。 HMSET命令 - 添加多个值除了HSET命令，HMSET命令的用途也是用来设置值，不同的是，HMSET一次可以设置多个 field-value (域-值)对设置到哈希表 key 中,语法如下：1HMSET key field value [field value ...] 示例 - 添加键age、sex。12127.0.0.1:6379&gt; HMSET man age \"24\" sex \"男\"OK 如果 key 不存在，将会创建一个空的哈希表并执行HMSET操作。如果添加的域已存在哈希表中，那么它将被覆盖。 HGET命令 - 获取值127.0.0.1:6379 中如何获取key的值呢？HGET是用来获取指定 key 值的命令，语法如下:1HGET key field 示例 - 获取域name的值。12127.0.0.1:6379&gt; HGET man name\"jaak zhang\" 执行HGET命令，如果 key 存在，将返回哈希表 key 中给定域 field 的值，如果 key 不存在，则返回 (nil) 。 HMGET命令 - 获取多个值作为HMSET命令对应的获取命令，HMGET可以一次性获取哈希表 key 中，一个或多个给定域的值基本语法：1HMGET key field [field ...] 示例 - 获取域name、age、sex的值。12345127.0.0.1:6379&gt; HMGET man name age sex # 返回值的顺序和传入参数的顺序一样1) \"jaak zhang\"2) \"24\"3) \"\\xe7\\x94\\xb7\" 如果给定的域不存在于哈希表，那么返回一个 nil 值。因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行HMGET操作将返回一个只带有 nil 值的表。 HGETALL命令 - 获取全部值如果我们想要一次性获取全部域的值，很显然 HGET 和 HMGET 都是不合适的，所幸的是我们还有HGETALL命令，通过它，我们可以轻松的获取到全部域值，基本语法：1HGETALL key 示例 - 获取man全部域的值。1234567127.0.0.1:6379&gt;HGETALL man1) \"name\" #域2) \"jaak zhang\" #值3) \"age\"4) \"24\"5) \"sex\"6) \"\\xe7\\x94\\xb7\" 在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。 HEXISTS命令 - 验证存在在应用环境中，我们经常会需要知道一个 key 中是否存在某个 field ，HEXISTS命令可以帮助我们达到这个目的基本语法：1HEXISTS key field 示例 - 验证键number是否存在。12127.0.0.1:6379&gt; HEXISTS man number (integer) 0 查看哈希表 key 中，给定域 field 是否存在。如果哈希表含有给定域，返回 1 。如果哈希表不含有给定域，或 key 不存在，返回 0 。 HKEYS命令 - 获取所有key我们经常会遇见这样的应用场景，比如在线用户列表、课堂列表等等，这时候我们可以使用HKEYS来获取哈希表 key 中的所有域基本语法：1HKEYS key 示例 - 查看键man中所有的域。1234127.0.0.1:6379&gt; HKEYS man1) \"name\"2) \"age\"3) \"sex\" 当 key 存在时，将返回一个包含哈希表中所有域的表。 当 key 不存在时，返回一个空表。 HLEN命令 - 获取域数量HLEN命令将返回哈希表 key 中域的数量,什么时候会用到它呢？比如：在线聊天室，显示在线用户数基本语法：1HLEN key 示例 - 查看man键中域的个数。12127.0.0.1:6379&gt; HLEN man(integer) 3 当 key 存在时，将返回哈希表中域的数量。 当 key 不存在时，返回 0 。 HDEL命令 - 删除有添加就必定有删除的需求，当我们想要删除哈希表 key 中的一个或多个指定域时，可以使用HDEL命令基本语法：1HDEL key field [field ...] 示例 - 删除键man中的sex域。12127.0.0.1:6379&gt; HDEL man sex(integer) 1 如果是不存在的域，那么它将被忽略掉。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangyake.github.io/categories/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zhangyake.github.io/tags/redis/"}]},{"title":"mongoose简单总结","slug":"mongoose01","date":"2015-11-16T02:25:40.000Z","updated":"2017-07-26T04:42:48.030Z","comments":true,"path":"2015/11/16/mongoose01/","link":"","permalink":"http://zhangyake.github.io/2015/11/16/mongoose01/","excerpt":"工作一年多了,一直再用node.js和PHP写后端. node.js写后端 数据库用mongodb ,第三方数据库操作模块就用的mongoose,在此总结一下mongoose的基本使用 Mongoose是什么Mongoose是MongoDB的一个对象模型工具，是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。","text":"工作一年多了,一直再用node.js和PHP写后端. node.js写后端 数据库用mongodb ,第三方数据库操作模块就用的mongoose,在此总结一下mongoose的基本使用 Mongoose是什么Mongoose是MongoDB的一个对象模型工具，是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。 Mongoose能做什么Mongoose，因为封装了对MongoDB对文档操作的常用处理方法，让NodeJS操作Mongodb数据库变得easy、easy、So easy! Mongoose使用安装mongoosenpm install mongoose 引用mongoosevar mongoose = require(&quot;mongoose&quot;); 使用”mongoose”连接数据库var db = mongoose.connect(&quot;mongodb://user:pass@localhost:port/database&quot;); 执行下面代码检查默认数据库test，是否可以正常连接成功 var mongoose = require(&quot;mongoose&quot;); var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;); db.connection.on(&quot;error&quot;, function (error) { console.log(&quot;数据库连接失败：&quot; + error); }); db.connection.on(&quot;open&quot;, function () { console.log(&quot;------数据库连接成功！------&quot;); }); 名词解释 Schema,Model,EntitySchema —— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。那如何去定义一个Schema，请看示例： var mongoose = require(&quot;mongoose&quot;); var TestSchema = new mongoose.Schema({ name : { type:String },//属性name,类型为String age : { type:Number, default:0 },//属性age,类型为Number,默认为0 time : { type:Date, default:Date.now }, email: { type:String,default:&apos;&apos;} }); Model —— 由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类。通过Schema来创建Model，如下示例： var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;); //…… // 创建Model var TestModel = db.model(&quot;test1&quot;, TestSchema); 拥有了Model，在后面就可以使用Model来进行增删改查的具体操作。 var TestSchema = new mongoose.Schema({ name : { type:String },//属性name,类型为String age : { type:Number, default:0 },//属性age,类型为Number,默认为0 time : { type:Date, default:Date.now }, email: { type:String,default:&apos;&apos;} }); var TestModel = db.model(&quot;test1&quot;, TestSchema); Entity —— 由Model创建的实体，使用save方法保存数据，Model和 Entity都有能影响数据库的操作，但Model比Entity更具操作性。使用Model创建Entity，如下示例： var TestEntity = new TestModel({ name : &quot;jaak&quot;, age : 25, email: &quot;jaak@qq.com&quot; }); console.log(TestEntity.name); // jaak console.log(TestEntity.age); // 25 Schema Model Entity 完整示例var mongoose = require(&quot;mongoose&quot;); var db = mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;); var TestSchema = new mongoose.Schema({ name : { type:String }, age : { type:Number, default:0 }, email: { type:String }, time : { type:Date, default:Date.now } }); var TestModel = db.model(&quot;test1&quot;, TestSchema ); var TestEntity = new TestModel({ name : &quot;helloworld&quot;, age : 28, email: &quot;helloworld@qq.com&quot; }); TestEntity.save(function(error,doc){ if(error){ console.log(&quot;error :&quot; + error); }else{ console.log(doc); } }); Schema：数据库集合的模型骨架，或者是数据属性模型传统意义的表结构。 Model ：通过Schema构造而成，除了具有Schema定义的数据库骨架以外，还可以具体的操作数据库。 Entity：通过Model创建的实体，它也可以操作数据库。Schema、Model、Entity的关系请牢记，Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性 Model 基本的find查询使用Model进行基本的find查询： Model.find(查询条件,callback); Model.find({},function(error,docs){ //若没有向find传递参数，默认的是显示所有文档 }); Model.find({ &quot;age&quot;: 28 }, function (error, docs) { if(error){ console.log(&quot;error :&quot; + error); }else{ console.log(docs); //docs: age为28的所有文档 } }); Model 保存方法 语法：Model.create(文档数据, callback)) 示例 : Model.create({ name:&quot;model_create&quot;, age:26}, function(error,doc){ if(error) { console.log(error); } else { console.log(doc); } }); Entity 保存方法语法 : Entity.save(文档数据, callback))示例: var Entity = new Model({name:&quot;entity_save&quot;,age: 27}); Entity.save(function(error,doc) { if(error) { console.log(error); } else { console.log(doc); } }); Model 数据更新 语法 : Model.update(查询条件,更新对象,callback); 示例: var conditions = {name : &apos;test_update&apos;}; var update = {$set : { age : 16 }}; Model.update(conditions, update, function(error){ if(error) { console.log(error); } else { console.log(&apos;Update success!&apos;); } }); Model 删除数据语法 : Model.remove(查询条件,callback);示例: var conditions = { name: &apos;tom&apos; }; Model.remove(conditions, function(error){ if(error) { console.log(error); } else { console.log(&apos;Delete success!&apos;); } }); Model find过滤查询语法 : 属性过滤 Model.find(Conditions,field,callback);field 说明：我们只需要把显示的属性设置为大于零的数就可以，当然1是最好理解的_id是默认返回 如果不要显示加上(“_id”:0)但是 对其他不需要显示的属性且不是_id 如果设置为0的话将会抛异常或查询无果。示例：//返回只包含一个键值name、age的所有记录 Model.find({},{name:1, age:1, _id:0}，function(err,docs){ //docs 查询结果集 }) Model findOne的基本用法与find相同，但只返回单个文档，也就说当查询到即一个符合条件的数据时，将停止继续查询，并返回查询结果。单条数据查询语法: Model.findOne(Conditions,callback); Model.findOne({ age: 27}, function (err, doc){ // 查询符合age等于27的第一条数据 // doc是查询结果 }); findOne方法，只返回第一个符合条件的文档数据。 Model findById的基本用法与findOne相同，但它只接收文档的_id作为参数，返回单个文档。单条数据查询语法: Model.findById(_id, callback); TestModel.findById(&apos;_id&apos;, function (err, doc){ //doc 查询结果文档 }); Model 条件查询&quot;$lt&quot;(小于)，&quot;$lte&quot;(小于等于),&quot;$gt&quot;(大于)，&quot;$gte&quot;(大于等于)，&quot;$ne&quot;(不等于)，&quot;$in&quot;(可单值和多个值的匹配)，&quot;$or&quot;(查询多个键值的任意给定值)，&quot;$exists&quot;(表示是否存在的意思)&quot;$all&quot; 使用$gt(&gt;)、$lt(&lt;)、$lte(&lt;=)、$gte(&gt;=)操作符进行排除性的查询，如下示例 Model.find({&quot;age&quot;:{&quot;$gt&quot;:18}},function(error,docs){ //查询所有nage大于18的数据 }); Model.find({&quot;age&quot;:{&quot;$lt&quot;:60}},function(error,docs){ //查询所有nage小于60的数据 }); Model.find({&quot;age&quot;:{&quot;$gt&quot;:18,&quot;$lt&quot;:60}},function(error,docs){ //查询所有nage大于18小于60的数据 }); $ne(!=)操作符的含义相当于不等于、不包含，查询时我们可通过它进行条件判定，具体使用方法如下 Model.find({ age:{ $ne:24}},function(error,docs){ //查询age不等于24的所有数据 }); Model.find({name:{$ne:&quot;tom&quot;},age:{$gte:18}},function(error,docs){ //查询name不等于tom、age&gt;=18的所有数据 }); 和$ne操作符相反，$in相当于包含、等于，查询时查找包含于指定字段条件的数据。具体使用方法如下 Model.find({ age:{ $in: 20}},function(error,docs){ //查询age等于20的所有数据 }); Model.find({ age:{$in:[20,30]}},function(error,docs){ //可以把多个值组织成一个数组 }); $or操作符，可以查询多个键值的任意给定值，只要满足其中一个就可返回，用于存在多个条件判定的情况下使用，如下示例 Model.find({&quot;$or&quot;:[{&quot;name&quot;:&quot;yaya&quot;},{&quot;age&quot;:28}]},function(error,docs){ //查询name为yaya或age为28的全部文档 }); $exists操作符，可用于判断某些关键字段是否存在来进行条件查询。如下示例 Model.find({name: {$exists: true}},function(error,docs){ //查询所有存在name属性的文档 }); Model.find({telephone: {$exists: false}},function(error,docs){ //查询所有不存在telephone属性的文档 }); limit的基本用法限制返回数量语法：Model.find(Conditions,fields,options,callback);示例： Model.find({},null,**{limit:20}**,function(err,docs){ console.log(docs); }); sort的基本用法对结果排序语法：Model.find(Conditions,fields,options,callback);示例： Model.find({},null,{sort:{age:-1}},function(err,docs){ //查询所有数据，并按照age降序顺序返回数据docs }); sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序 skip的基本用法跳过数量：find(Conditions,fields,options,callback); Model.find({},null,**{skip:4}**,function(err,docs){ console.log(docs); }); 如果查询结果数量中少于4个的话，则不会返回任何结果。 skip limit sort 联合查询 示例 Model.find({},null,{skip:0,limit:2,sort:{age:1}},function(err,docs){ // ... }); 链式查询这种方式相对直接查询，分的比较明细，如果不带 callback，则返回 query，query 表示没有执行的预编译查询语句，该 query 对象执行的方法都将返回自己，只有在执行 exec 方法时才执行查询，而且必须有回调。 var query = Model .find({ age: 24}) .limit(10) .skip(5); query.exec(function(err,docs){ if(err){ //... }else{ console.log(docs); } });","categories":[{"name":"后端","slug":"后端","permalink":"http://zhangyake.github.io/categories/后端/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://zhangyake.github.io/tags/mongoose/"}]},{"title":"Hexo入住","slug":"article01","date":"2015-10-13T07:15:02.000Z","updated":"2017-07-26T04:42:48.025Z","comments":true,"path":"2015/10/13/article01/","link":"","permalink":"http://zhangyake.github.io/2015/10/13/article01/","excerpt":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。","text":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染 支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 如何使用？ Hexo官方网站: https://hexo.io/","categories":[{"name":"工具","slug":"工具","permalink":"http://zhangyake.github.io/categories/工具/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zhangyake.github.io/tags/Hexo/"}]}]}